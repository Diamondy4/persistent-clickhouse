{-# LANGUAGE ScopedTypeVariables #-}

module Database.Persist.ClickHouse.Internal.Backend (ClickhouseBackend (..)) where

import Control.Monad.Logger (logDebugNS, runLoggingT)
import Control.Monad.Reader (ask, void)
import qualified Data.Aeson as A
import qualified Data.ByteString.Lazy.Char8 as BSC
import Data.Coerce
import Data.Foldable
import qualified Data.Foldable as Foldable
import Data.IORef
import Data.Map (Map)
import Data.Maybe
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.Vector as V
import Data.Void
import Database.Clickhouse.Conversion.Types
import Database.Clickhouse.Conversion.Values.Renderer
import Database.Clickhouse.Types
import Database.Persist
import Database.Persist.ClickHouse.Internal.Migrate
import Database.Persist.ClickHouse.Internal.Misc
import Database.Persist.ClickHouse.Internal.SQL
import Database.Persist.ClickHouse.Internal.SqlBackend
import Database.Persist.Sql
import Database.Persist.Sql.Util
import Database.Persist.SqlBackend
import GHC.Generics
import Optics ((^.))

{- | Clickhouse connection. Note that it is static - ClickHouse
 doesn't need to keep it open, every action is atomic.
-}
data ClickhouseBackend connectionType = ClickhouseBackend
  { -- | Settings that are indifferent to connection type, i.e. login/password/schema
    env :: !ClickhouseConnectionSettings
  , -- | Settings specific to connection type, i.e. host/port for HTTP
    settings :: !(ClickhouseClientSettings connectionType)
  , -- | Used in conversion to SqlBackend
    stmtMap :: !(IORef (Map Text Statement))
  , logFunc :: !LogFunc
  }
  deriving (Generic)

-- | Clickhouse doesn't use autogenerated keys, key must provide manually for table.
instance PersistCore (ClickhouseBackend connectionType) where
  newtype BackendKey (ClickhouseBackend connectionType) = ClickhouseBackendKey Void
    deriving stock (Show, Read, Eq, Ord, Generic)
    deriving newtype (A.ToJSON, A.FromJSON)

instance PersistField (BackendKey (ClickhouseBackend connectionType)) where
  toPersistValue v = absurd (coerce v)
  fromPersistValue _ = Left "Clickhouse doesn't use default primary key, please specify it manually"

clickhouseBackendToSqlBackend ::
  forall connectionType.
  (ClickhouseClientSource connectionType) =>
  ClickhouseBackend connectionType ->
  SqlBackend
clickhouseBackendToSqlBackend clickbackend =
  mkSqlBackend
    MkSqlBackendArgs
      { connPrepare = prepare' (clickbackend ^. #settings) (clickbackend ^. #env)
      , connInsertSql = insertSqlBackend'
      , connStmtMap = clickbackend ^. #stmtMap
      , connClose = return ()
      , connMigrateSql = migrate' $ clickbackend ^. #env
      , connBegin = \_ _ -> return ()
      , connCommit = \_ -> return ()
      , connRollback = \_ -> return ()
      , connEscapeFieldName = T.pack . escapeF
      , connEscapeTableName = T.pack . escapeE . getEntityDBName
      , connEscapeRawName = T.pack . escapeDBName . T.unpack
      , connNoLimit = "LIMIT 18446744073709551615"
      , connRDBMS = "clickhouse"
      , connLimitOffset = decorateSQLWithLimitOffset "LIMIT 18446744073709551615"
      , connLogFunc = clickbackend ^. #logFunc
      }

instance (ClickhouseClientSource connectionType) => BackendCompatible SqlBackend (ClickhouseBackend connectionType) where
  projectBackend = clickhouseBackendToSqlBackend

instance (ClickhouseClientSource connectionType) => HasPersistBackend (ClickhouseBackend connectionType) where
  type BaseBackend (ClickhouseBackend connectionType) = SqlBackend
  persistBackend = clickhouseBackendToSqlBackend

instance (ClickhouseClientSource connectionType) => PersistStoreRead (ClickhouseBackend connectionType) where
  get k = withBaseBackend $ get k
  getMany ks = withBaseBackend $ getMany ks

instance (ClickhouseClientSource connectionType) => PersistUniqueRead (ClickhouseBackend connectionType) where
  getBy k = withBaseBackend $ getBy k

instance (ClickhouseClientSource connectionType) => PersistStoreWrite (ClickhouseBackend connectionType) where
  insert val = do
    let esql = insertSqlValues' t vals

    case esql of
      InsertClickhouseQuery sql fs -> do
        rawExecute sql vals
        case entityPrimary t of
          Nothing ->
            error $ "Primary key is not defined " ++ show sql
          Just pdef ->
            let pks = Foldable.toList $ fieldHaskell <$> compositeFields pdef
                keyvals = map snd $ filter (\(a, _) -> let ret = isJust (find (== a) pks) in ret) $ zip (map fieldHaskell $ getEntityFields t) fs
             in case keyFromValues keyvals of
                  Right k -> return k
                  Left e -> error $ "InsertClickhouseQuery: unexpected keyvals result: " `mappend` T.unpack e
   where
    t = entityDef $ Just val
    vals = mkInsertValues val

  insertMany recs = do
    conn <- ask
    let esql = insertManySql' t valsV
    case esql of
      InsertManyClickhouseQuery sql _ -> do
        runLoggingT
          (logDebugNS "SQL" $ T.append sql "; " <> T.pack (show vals))
          (logFunc conn)
        let preparedQuery = PreparedQuery . BSC.fromStrict $ TE.encodeUtf8 sql
        let renderedQuery = renderRows preparedQuery clickhouseTypeVals
        void $ send (conn ^. #settings) (conn ^. #env) renderedQuery
        case entityPrimary t of
          Nothing ->
            error $ "Primary key is not defined " ++ show sql
          Just pdef ->
            let pks = Foldable.toList $ fieldHaskell <$> compositeFields pdef
                getKeyvals fs = map snd $ filter (\(a, _) -> let ret = isJust (find (== a) pks) in ret) $ zip (map fieldHaskell $ getEntityFields t) fs
                processKeyvals keyvals = case keyFromValues keyvals of
                  Right k -> k
                  Left e -> error $ "InsertClickhouseQuery: unexpected keyvals result: " `mappend` T.unpack e
             in pure $ processKeyvals . getKeyvals <$> vals
   where
    vals = mkInsertValues <$> recs
    valsV = V.fromList $ mkInsertValues <$> recs
    clickhouseTypeVals = rowsPersistValueToClickhouseType vals
    t = entityDef recs

  insertKey = error "Clickhouse doesn't support insertion by key, please use insert with whole record"

  -- TODO: Think what to do with mutation statements. Currently they are unsupported but must be defined for
  -- PersistStoreWrite. Maybe split the  typeclass in persistent package?
  repsert = error "Repsert functionality is not implemented for Clickhouse as it dangerous to be called"
  replace = error "Replace functionality is not implemented for Clickhouse as it dangerous to be called"
  delete = error "Delete functionality is not implemented for Clickhouse as it dangerous to be called"
  update = error "Update functionality is not implemented for Clickhouse as it dangerous to be called"

instance (ClickhouseClientSource connectionType) => PersistQueryRead (ClickhouseBackend connectionType) where
  selectSourceRes f opts = withBaseBackend $ selectSourceRes f opts
  selectKeysRes f opts = withBaseBackend $ selectKeysRes f opts
  count f = withBaseBackend $ count f
  exists f = withBaseBackend $ exists f